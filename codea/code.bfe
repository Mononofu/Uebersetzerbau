%{
#define CODE

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "tree.h"
#include "helpers.h"

/* TODO (-a)+b */
/* TODO func f(a,a) return a; end; shall do the same as func f(b,a) return a; end; */

/* constant folding: not working

epc:      expr                            # 0 # bnode->reg = bnode->kids[0]->reg;
epc:      OP_ADD(epc, imm)                # 0 # bnode->reg = bnode->kids[0]->reg; bnode->value = bnode->kids[0]->value + bnode->kids[1]->value;
epc:      OP_ADD(imm, epc)                # 0 # bnode->reg = bnode->kids[1]->reg; bnode->value = bnode->kids[0]->value + bnode->kids[1]->value;
expr:     OP_ADD(epc, epc)                # 1 # bnode->reg = bnode->kids[0]->reg; printf("\tlea %li(%%%s, %%%s, 1), %%%s\n", bnode->kids[0]->value + bnode->kids[1]->value, bnode->kids[0]->reg, bnode->kids[1]->reg, bnode->reg);
expr:     epc                             # 1 #  bnode->reg = bnode->kids[0]->reg;  printf("\taddq $%li, %%%s\n", bnode->kids[0]->value, bnode->kids[0]->reg);

*/

%}

%start stat
%term OP_NOT=1 OP_AND=2 OP_OR=3 OP_EQ=4 OP_GT=5 OP_GEQ=6 OP_LS=7 OP_LEQ=8 OP_NEQ=9 OP_ADD=10 OP_MUL=11 OP_NEG=12 OP_ID=13 OP_Number=14 OP_Field=15 OP_Return=16 OP_Zero=17 OP_One=18 OP_Args=19 OP_Call=20 OP_ReadMem=21 OP_IF=22 OP_Stats=23 OP_NOP=24

%%

stat:    ret                              # 0 #
stat:    OP_IF(expr)                      # 0 #
stat:    OP_IF(imm)                       # 0 # bnode->value = bnode->kids[0]->value;

ret:     OP_Return(expr)                  # 1 # move(bnode->kids[0]->reg, "rax"); ret(); 
ret:     OP_Return(OP_ADD(expr, expr))    # 1 # printf("\tlea (%%%s, %%%s, 1), %%rax\n", bnode->kids[0]->kids[0]->reg, bnode->kids[0]->kids[1]->reg); freereg(bnode->kids[0]->kids[0]->reg); freereg(bnode->kids[0]->kids[1]->reg); ret();
ret:     OP_Return(OP_ADD(imm, expr))     # 1 # printf("\tlea %li(%%%s), %%rax\n", bnode->kids[0]->kids[0]->value, bnode->kids[0]->kids[1]->reg); freereg(bnode->kids[0]->kids[1]->reg); ret();
ret:     OP_Return(OP_ADD(expr, imm))     # 1 # printf("\tlea %li(%%%s), %%rax\n", bnode->kids[0]->kids[1]->value, bnode->kids[0]->kids[0]->reg); freereg(bnode->kids[0]->kids[0]->reg); ret();

expr:    OP_ID                            # 0 # bnode->reg = reg_for_var(bnode->name); 
expr:    imm                              # 1 # bnode->reg = newreg(); printf("\tmovq $%li, %%%s", bnode->value, bnode->reg);
expr:    call                             # 0 #

expr:    OP_NOT(expr)                     # 2 # freereg(bnode->kids[0]->reg); bnode->reg = newreg(); move(bnode->kids[0]->reg, bnode->reg);  printf("\tnot %%%s\n", bnode->reg);
expr:    OP_NOT(OP_NOT(expr))             # 0 # bnode->reg = bnode->kids[0]->kids[0]->reg; 

expr:    OP_NEG(expr)                     # 1 # freereg(bnode->kids[0]->reg); bnode->reg = newreg(); printf("\timul $-1, %%%s, %%%s\n", bnode->kids[0]->reg, bnode->reg);
expr:    OP_NEG(OP_NEG(expr))             # 0 # bnode->reg = bnode->kids[0]->kids[0]->reg; 

expr:    OP_ADD(expr,expr)                # 1 # free_childs_alloc_reg(bnode); printf("\tlea (%%%s, %%%s, 1), %%%s\n", bnode->kids[1]->reg, bnode->kids[0]->reg, bnode->reg);
expr:    OP_ADD(imm,expr)                 # 1 # free_childs_alloc_reg(bnode); printf("\tlea %li(%%%s), %%%s\n", bnode->kids[0]->value, bnode->kids[1]->reg, bnode->reg);
expr:    OP_ADD(expr,imm)                 # 1 # free_childs_alloc_reg(bnode); printf("\tlea %li(%%%s), %%%s\n", bnode->kids[1]->value, bnode->kids[0]->reg, bnode->reg);
expr:    OP_ADD(expr,zero)                # 0 # bnode->reg = bnode->kids[0]->reg;
expr:    OP_ADD(zero,expr)                # 0 # bnode->reg = bnode->kids[1]->reg;

expr:    OP_MUL(expr,expr)                # 2 # free_childs_alloc_reg(bnode); move(bnode->kids[0]->reg, bnode->reg); printf("\timul %%%s, %%%s\n", bnode->kids[1]->reg, bnode->reg);
expr:    OP_MUL(imm,expr)                 # 1 # free_childs_alloc_reg(bnode); printf("\timul $%li, %%%s, %%%s\n", bnode->kids[0]->value, bnode->kids[1]->reg, bnode->reg);
expr:    OP_MUL(expr,imm)                 # 1 # free_childs_alloc_reg(bnode); printf("\timul $%li, %%%s, %%%s\n", bnode->kids[1]->value, bnode->kids[0]->reg, bnode->reg);

expr:    OP_AND(expr, expr)               # 2 # bnode->reg = newreg(); move(bnode->kids[1]->reg, bnode->reg); printf("\tand %%%s, %%%s\n", bnode->kids[0]->reg, bnode->reg); freereg(bnode->kids[0]->reg); freereg(bnode->kids[1]->reg); 
expr:    OP_AND(imm, expr)                # 2 # freereg(bnode->kids[1]->reg); bnode->reg = newreg(); move(bnode->kids[1]->reg, bnode->reg); printf("\tand $%li, %%%s\n", bnode->kids[0]->value, bnode->reg); 
expr:    OP_AND(expr, imm)                # 2 # freereg(bnode->kids[0]->reg); bnode->reg = newreg(); move(bnode->kids[0]->reg, bnode->reg); printf("\tand $%li, %%%s\n", bnode->kids[1]->value, bnode->reg); 

expr:    OP_NEQ(expr, expr)               # 3 # bnode->reg = newreg(); printf("\txor %%%s, %%%s\n", bnode->reg, bnode->reg);  printf("\tcmpq %%%s, %%%s\n", bnode->kids[1]->reg, bnode->kids[0]->reg); printf("\tsetne %%%s\n", get_8bit_reg(bnode->reg)); freereg(bnode->kids[0]->reg); freereg(bnode->kids[1]->reg); 
expr:    OP_NEQ(imm, expr)                # 3 # bnode->reg = newreg(); printf("\txor %%%s, %%%s\n", bnode->reg, bnode->reg);  printf("\tcmpq $%li, %%%s\n", bnode->kids[0]->value, bnode->kids[1]->reg); printf("\tsetne %%%s\n", get_8bit_reg(bnode->reg)); freereg(bnode->kids[1]->reg); 
expr:    OP_NEQ(expr, imm)                # 3 # bnode->reg = newreg(); printf("\txor %%%s, %%%s\n", bnode->reg, bnode->reg);  printf("\tcmpq $%li, %%%s\n", bnode->kids[1]->value, bnode->kids[0]->reg); printf("\tsetne %%%s\n", get_8bit_reg(bnode->reg)); freereg(bnode->kids[0]->reg); 

expr:    OP_LEQ(expr, expr)               # 3 # bnode->reg = newreg(); printf("\txor %%%s, %%%s\n", bnode->reg, bnode->reg);  printf("\tcmpq %%%s, %%%s\n", bnode->kids[1]->reg, bnode->kids[0]->reg); printf("\tsetle %%%s\n", get_8bit_reg(bnode->reg)); freereg(bnode->kids[0]->reg); freereg(bnode->kids[1]->reg); 
expr:    OP_LEQ(imm, expr)                # 3 # bnode->reg = newreg(); printf("\txor %%%s, %%%s\n", bnode->reg, bnode->reg);  printf("\tcmpq $%li, %%%s\n", bnode->kids[0]->value, bnode->kids[1]->reg); printf("\tsetle %%%s\n", get_8bit_reg(bnode->reg)); freereg(bnode->kids[1]->reg); 
expr:    OP_LEQ(expr, imm)                # 3 # bnode->reg = newreg(); printf("\txor %%%s, %%%s\n", bnode->reg, bnode->reg);  printf("\tcmpq $%li, %%%s\n", bnode->kids[1]->value, bnode->kids[0]->reg); printf("\tsetle %%%s\n", get_8bit_reg(bnode->reg)); freereg(bnode->kids[0]->reg); 


expr:    OP_ReadMem(expr)                 # 1 # freereg(bnode->kids[0]->reg); bnode->reg = newreg(); printf("\tmovq (%%%s), %%%s\n", bnode->kids[0]->reg, bnode->reg);
expr:    OP_ReadMem(imm)                  # 1 # bnode->reg = newreg(); printf("\tmovq ($%li), %%%s\n", bnode->kids[0]->value, bnode->reg);





call:    OP_Call(OP_ID,exprs)             # 0 # /* ignore at the moment */

exprs:    expr                            # 0 #
exprs:    OP_Args(exprs,expr)             # 0 #

zero:    OP_Zero                          # 0 #
zero:    OP_NEG(zero)                     # 0 #
zero:    OP_MUL(zexpr,zero)               # 0 #
zero:    OP_MUL(zero,zexpr)               # 0 #

zexpr:    zero                            # 0 #
zexpr:    imm                             # 0 #
zexpr:    OP_ADD(zexpr,zexpr)             # 0 #
zexpr:    OP_NEG(zexpr)                   # 0 #
zexpr:    OP_MUL(zexpr,zexpr)             # 0 #
zexpr:    OP_Field(zexpr,OP_ID)           # 0 #
zexpr:    OP_ID                           # 0 #

imm:    zero                              # 0 #
imm:    OP_NEG(imm)                       # 0 # bnode->value= - (bnode->kids[0]->value);
imm:    OP_NOT(imm)                       # 0 # bnode->value= ~ (bnode->kids[0]->value);
imm:    OP_ADD(imm,imm)                   # 0 # bnode->value=bnode->kids[0]->value+bnode->kids[1]->value;
imm:    OP_MUL(imm,imm)                   # 0 # bnode->value=bnode->kids[0]->value*bnode->kids[1]->value;
imm:    OP_Number                         # 0 # 
imm:    OP_Zero                           # 0 # 
imm:    OP_One                            # 0 # 

%%


